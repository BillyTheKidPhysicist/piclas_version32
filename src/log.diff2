diff --git a/src/interpolation/eval_xyz.f90 b/src/interpolation/eval_xyz.f90
index ae11c2d..f43de50 100644
--- a/src/interpolation/eval_xyz.f90
+++ b/src/interpolation/eval_xyz.f90
@@ -42,7 +42,7 @@ PUBLIC :: eval_xyz_curved,eval_xyz_elemcheck, eval_xyz_part2,eval_xyz_poly
 CONTAINS
 
 !#ifdef PARTICLES
-SUBROUTINE eval_xyz_curved(x_in,NVar,N_in,U_In,U_Out,ElemID)!,PartID)
+SUBROUTINE eval_xyz_curved(x_in,NVar,N_in,U_In,U_Out,ElemID,PartID)
 !===================================================================================================================================
 ! interpolate a 3D tensor product Lagrange basis defined by (N_in+1) 1D interpolation point positions x
 ! first get xi,eta,zeta from x,y,z...then do tenso product interpolation
@@ -69,7 +69,7 @@ INTEGER,INTENT(IN)  :: N_In                                  ! usually PP_N
 INTEGER,INTENT(IN)  :: ElemID                                 ! elem index
 REAL,INTENT(IN)     :: U_In(1:NVar,0:N_In,0:N_In,0:N_In)   ! elem state
 REAL,INTENT(IN)     :: x_in(3)                                  ! physical position of particle 
-!INTEGER,INTENT(IN),OPTIONAL :: PartID
+INTEGER,INTENT(IN),OPTIONAL :: PartID
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! OUTPUT VARIABLES
 REAL,INTENT(OUT)    :: U_Out(1:NVar)  ! Interpolated state
@@ -146,7 +146,8 @@ REAL,ALLOCATABLE    :: L_xi_BGField(:,:), U_BGField(:)
 !END IF
 
 IF(CurvedElem(ElemID))THEN
-  CALL RefElemNewton(Xi,X_In,wBaryCL_NGeo,XiCL_NGeo,XCL_NGeo(:,:,:,:,ElemID),dXCL_NGeo(:,:,:,:,:,ElemID),NGeo,ElemID,Mode=1)
+  CALL
+  RefElemNewton(Xi,X_In,wBaryCL_NGeo,XiCL_NGeo,XCL_NGeo(:,:,:,:,ElemID),dXCL_NGeo(:,:,:,:,:,ElemID),NGeo,ElemID,Mode=1,PartID=PartID)
 ELSE
   ! fill dummy XCL_NGeo1
   XCL_NGeo1(1:3,0,0,0) = XCL_NGeo(1:3, 0  , 0  , 0  ,ElemID)
@@ -166,7 +167,7 @@ ELSE
   dXCL_NGeo1(1:3,1:3,1,0,1) = dXCL_NGeo(1:3,1:3,NGeo, 0  ,NGeo,ElemID)
   dXCL_NGeo1(1:3,1:3,0,1,1) = dXCL_NGeo(1:3,1:3, 0  ,NGeo,NGeo,ElemID)
   dXCL_NGeo1(1:3,1:3,1,1,1) = dXCL_NGeo(1:3,1:3,NGeo,NGeo,NGeo,ElemID)
-  CALL RefElemNewton(Xi,X_In,wBaryCL_NGeo1,XiCL_NGeo1,XCL_NGeo1,dXCL_NGeo1,1,ElemID,Mode=1)
+  CALL RefElemNewton(Xi,X_In,wBaryCL_NGeo1,XiCL_NGeo1,XCL_NGeo1,dXCL_NGeo1,1,ElemID,Mode=1,PartID=PartID)
 END IF
 
 ! IF(ANY(ABS(Xi).GT.1.1)) THEN
@@ -541,7 +542,7 @@ END IF ! useBGField
 END SUBROUTINE eval_xyz_part2
 
 
-SUBROUTINE RefElemNewton(Xi,X_In,wBaryCL_N_In,XiCL_N_In,XCL_N_In,dXCL_N_In,N_In,ElemID,Mode)
+SUBROUTINE RefElemNewton(Xi,X_In,wBaryCL_N_In,XiCL_N_In,XCL_N_In,dXCL_N_In,N_In,ElemID,Mode,PartID)
 !=================================================================================================================================
 ! Netwon for finding the position inside the reference element [-1,1] for an arbitrary physical point
 !=================================================================================================================================
@@ -551,11 +552,15 @@ USE MOD_Globals_Vars
 USE MOD_Basis,                   ONLY:LagrangeInterpolationPolys
 USE MOD_Particle_Mesh_Vars,      ONLY:RefMappingEps!,ElemRadiusNGeo
 USE MOD_Mesh_Vars,               ONLY:offsetElem
+#if (PP_TimeDiscMethod==121) || (PP_TimeDiscMethod==122)
+USE MOD_Particle_Vars,           ONLY:PartIsImplicit,LastPartPos
+#endif
 !----------------------------------------------------------------------------------------------------------------------------------!
 IMPLICIT NONE
 ! INPUT VARIABLES 
 INTEGER,INTENT(IN)               :: N_In,ElemID
 INTEGER,INTENT(IN)               :: Mode
+INTEGER,INTENT(IN),OPTIONAL      :: PartID
 REAL,INTENT(IN)                  :: X_in(3) ! position in physical space 
 REAL,INTENT(IN)                  :: XiCL_N_in(0:N_In)               ! position of CL points in reference space
 REAL,INTENT(IN)                  ::  XCL_N_in(3,0:N_In,0:N_in,0:N_In) ! position of CL points in physical space
@@ -648,7 +653,11 @@ __STAMP__&
       IPWRITE(UNIT_stdOut,*) ' xi  ', xi(1:3)
       IPWRITE(UNIT_stdOut,*) ' PartPos', X_in
       IPWRITE(UNIT_stdOut,*) ' ElemID', ElemID+offSetElem
-      !IF(PRESENT(PartID)) IPWRITE(UNIT_stdOut,*) ' PartID', PartID
+      IF(PRESENT(PartID)) IPWRITE(UNIT_stdOut,*) ' PartID', PartID
+#if (PP_TimeDiscMethod==121) || (PP_TimeDiscMethod==122)
+      IF(PRESENT(PartID)) IPWRITE(UNIT_stdOut,*) ' implicit?', PartisImplicit(PartID)
+      IF(PRESENT(PartID)) IPWRITE(UNIT_stdOut,*) ' last?', LastPartPos(PartID,1:3)
+#endif
       CALL abort(&
 __STAMP__&
 ,'Particle Not inSide of Element, ElemID,',ElemID)
diff --git a/src/linearsolver/newton.f90 b/src/linearsolver/newton.f90
index 533b86a..d55f342 100644
--- a/src/linearsolver/newton.f90
+++ b/src/linearsolver/newton.f90
@@ -251,6 +251,12 @@ IF (t.GE.DelayTime) THEN
       CALL ParticleTracing(doParticle_In=PartisImplicit(1:PDM%ParticleVecLength)) 
     END IF
   END IF
+  DO iPart=1,PDM%ParticleVecLength
+    IF(PartIsImplicit(iPart))THEN
+      IF(.NOT.PDM%ParticleInside(iPart)) PartisImplicit(iPart)=.FALSE.
+    END IF
+  END DO
+
   ! send number of particles
   CALL SendNbOfParticles(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
   ! finish communication of number of particles and send particles
@@ -319,14 +325,14 @@ DO WHILE ((nFullNewtonIter.LE.maxFullNewtonIter).AND.(.NOT.IsConverged))
 
 #ifdef PARTICLES
   IF (t.GE.DelayTime) THEN
-    DO iPart=1,PDM%ParticleVecLength
-      IF(PartIsImplicit(iPart))THEN
-        LastPartPos(iPart,1)=PartState(iPart,1)
-        LastPartPos(iPart,2)=PartState(iPart,2)
-        LastPartPos(iPart,3)=PartState(iPart,3)
-        PEM%lastElement(iPart)=PEM%Element(iPart)
-      END IF ! PartIsImplicit
-    END DO ! iPart
+    !DO iPart=1,PDM%ParticleVecLength
+    !  IF(PartIsImplicit(iPart))THEN
+    !    LastPartPos(iPart,1)=PartState(iPart,1)
+    !    LastPartPos(iPart,2)=PartState(iPart,2)
+    !    LastPartPos(iPart,3)=PartState(iPart,3)
+    !    PEM%lastElement(iPart)=PEM%Element(iPart)
+    !  END IF ! PartIsImplicit
+    !END DO ! iPart
 
     ! now, we have an initial guess for the field  can compute the first particle movement
     IF(FullEisenstatWalker.GT.1)THEN
@@ -374,6 +380,11 @@ DO WHILE ((nFullNewtonIter.LE.maxFullNewtonIter).AND.(.NOT.IsConverged))
       END IF
       !PartRelaxationFac=MIN(PartRelaxationFac*1.2,1.6)
     END IF
+    DO iPart=1,PDM%ParticleVecLength
+      IF(PartIsImplicit(iPart))THEN
+        IF(.NOT.PDM%ParticleInside(iPart)) PartisImplicit(iPart)=.FALSE.
+      END IF
+    END DO
     ! send number of particles
     CALL SendNbOfParticles(doParticle_In=PartIsImplicit(1:PDM%ParticleVecLength))
     ! finish communication of number of particles and send particles
diff --git a/src/linearsolver/particlesolver.f90 b/src/linearsolver/particlesolver.f90
index 47efaa4..f375b47 100644
--- a/src/linearsolver/particlesolver.f90
+++ b/src/linearsolver/particlesolver.f90
@@ -207,7 +207,7 @@ IMPLICIT NONE
 !-----------------------------------------------------------------------------------------------------------------------------------
 ! INPUT VARIABLES
 REAL,INTENT(IN)               :: t,coeff
-LOGICAL,INTENT(IN),OPTIONAL   :: doParticle_In(1:PDM%maxParticleNumber)
+LOGICAL,INTENT(INOUT),OPTIONAL:: doParticle_In(1:PDM%maxParticleNumber)
 LOGICAL,INTENT(IN),OPTIONAL   :: opt_In
 REAL,INTENT(IN),OPTIONAL      :: AbortTol_In
 !-----------------------------------------------------------------------------------------------------------------------------------
@@ -262,6 +262,11 @@ IF(opt)THEN ! compute zero state
   ! whole pt array
   DO iPart=1,PDM%ParticleVecLength
     IF(DoPartInNewton(iPart))THEN
+      ! update the last part pos and element for particle movement
+      LastPartPos(iPart,1)=PartState(iPart,1)
+      LastPartPos(iPart,2)=PartState(iPart,2)
+      LastPartPos(iPart,3)=PartState(iPart,3)
+      PEM%lastElement(iPart)=PEM%Element(iPart)
       CALL InterpolateFieldToSingleParticle(iPart,FieldAtParticle(iPart,1:6))
       SELECT CASE(PartLorentzType)
       CASE(0)
@@ -299,6 +304,16 @@ IF(opt)THEN ! compute zero state
       END IF
     END IF ! ParticleInside
   END DO ! iPart
+ELSE
+  DO iPart=1,PDM%ParticleVecLength
+    IF(DoPartInNewton(iPart))THEN
+      ! update the last part pos and element for particle movement
+      LastPartPos(iPart,1)=PartState(iPart,1)
+      LastPartPos(iPart,2)=PartState(iPart,2)
+      LastPartPos(iPart,3)=PartState(iPart,3)
+      PEM%lastElement(iPart)=PEM%Element(iPart)
+    END IF ! ParticleInside
+  END DO ! iPart
 END IF
 
 #ifdef MPI
@@ -345,10 +360,11 @@ DO WHILE((DoNewton) .AND. (nInnerPartNewton.LT.nPartNewtonIter))  ! maybe change
       ! update to new partstate during Newton iteration
       PartXK(:,iPart)=PartXK(:,iPart)+DeltaX
       PartState(iPart,:)=PartXK(:,iPart)
-      DeltaX_Norm=DOT_PRODUCT(DeltaX,DeltaX)
-      IF(DeltaX_Norm.LT.AbortTol*Norm2_F_PartX0(iPart)) THEN
-        DoPartInNewton(iPart)=.FALSE.
-      END IF
+      ! forbidden, because particle is NOT moved but has to be traced...
+      !DeltaX_Norm=DOT_PRODUCT(DeltaX,DeltaX)
+      !IF(DeltaX_Norm.LT.AbortTol*Norm2_F_PartX0(iPart)) THEN
+      !  DoPartInNewton(iPart)=.FALSE.
+      !END IF
     END IF ! ParticleInside
   END DO ! iPart
   ! closed form: now move particles
@@ -365,6 +381,13 @@ DO WHILE((DoNewton) .AND. (nInnerPartNewton.LT.nPartNewtonIter))  ! maybe change
       ! input value: which list:DoPartInNewton or PDM%ParticleInisde?
       CALL ParticleTracing(doParticle_In=DoPartInNewton(1:PDM%ParticleVecLength)) 
     END IF
+    DO iPart=1,PDM%ParticleVecLength
+      IF(DoPartInNewton(iPart))THEN
+        IF(.NOT.PDM%ParticleInside(iPart))THEN
+          DoPartInNewton(iPart)=.FALSE.
+        END IF
+      END IF
+    END DO
 #ifdef MPI
     ! send number of particles
     CALL SendNbOfParticles(doParticle_In=DoPartInNewton(1:PDM%ParticleVecLength)) 
diff --git a/src/particles/pic/interpolation/pic_interpolation.f90 b/src/particles/pic/interpolation/pic_interpolation.f90
index fc954b7..ca3e337 100644
--- a/src/particles/pic/interpolation/pic_interpolation.f90
+++ b/src/particles/pic/interpolation/pic_interpolation.f90
@@ -341,25 +341,25 @@ IF (DoInterpolation) THEN                 ! skip if no self fields are calculate
 #ifdef PP_POIS
             HelperU(1:3,:,:,:) = E(1:3,:,:,:,iElem)
             HelperU(4:6,:,:,:) = U(4:6,:,:,:,iElem)
-            CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),iElem)
+            CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),iElem,iPart)
 #else
-            CALL eval_xyz_curved(Pos,6,PP_N,U(1:6,:,:,:,iElem),field(1:6),iElem)
+            CALL eval_xyz_curved(Pos,6,PP_N,U(1:6,:,:,:,iElem),field(1:6),iElem,iPart)
 #endif
 #else
 #ifdef PP_POIS
-            CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,iElem),field(1:3),iElem)
+            CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,iElem),field(1:3),iElem,iPart)
 #elif defined PP_HDG
 #if PP_nVar==1
-            CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,iElem),field(1:3),iElem)
+            CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,iElem),field(1:3),iElem,iPart)
 #elif PP_nVar==3
-            CALL eval_xyz_curved(Pos,3,PP_N,B(1:3,:,:,:,iElem),field(4:6),iElem)
+            CALL eval_xyz_curved(Pos,3,PP_N,B(1:3,:,:,:,iElem),field(4:6),iElem,iPart)
 #else
             HelperU(1:3,:,:,:) = E(1:3,:,:,:,iElem)
             HelperU(4:6,:,:,:) = B(1:3,:,:,:,iElem)
-            CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),iElem)
+            CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),iElem,iPart)
 #endif
 #else
-            CALL eval_xyz_curved(Pos,3,PP_N,U(1:3,:,:,:,iElem),field(1:3),iElem)
+            CALL eval_xyz_curved(Pos,3,PP_N,U(1:3,:,:,:,iElem),field(1:3),iElem,iPart)
 #endif         
 #endif
             FieldAtParticle(iPart,:) = FieldAtParticle(iPart,:) + field(1:6)
@@ -639,25 +639,25 @@ IF (DoInterpolation) THEN                 ! skip if no self fields are calculate
 #ifdef PP_POIS
       HelperU(1:3,:,:,:) = E(1:3,:,:,:,ElemID)
       HelperU(4:6,:,:,:) = U(4:6,:,:,:,ElemID)
-      CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),ElemID)
+      CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),ElemID,PartID)
 #else
-      CALL eval_xyz_curved(Pos,6,PP_N,U(1:6,:,:,:,ElemID),field(1:6),ElemID)
+      CALL eval_xyz_curved(Pos,6,PP_N,U(1:6,:,:,:,ElemID),field(1:6),ElemID,PartID)
 #endif
 #else
 #ifdef PP_POIS
-      CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,ElemID),field(1:3),ElemID)
+      CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,ElemID),field(1:3),ElemID,PartID)
 #elif defined PP_HDG
 #if PP_nVar==1
-      CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,ElemID),field(1:3),ElemID)
+      CALL eval_xyz_curved(Pos,3,PP_N,E(1:3,:,:,:,ElemID),field(1:3),ElemID,PartID)
 #elif PP_nVar==3
-      CALL eval_xyz_curved(Pos,3,PP_N,B(1:3,:,:,:,ElemID),field(4:6),ElemID)
+      CALL eval_xyz_curved(Pos,3,PP_N,B(1:3,:,:,:,ElemID),field(4:6),ElemID,PartID)
 #else
       HelperU(1:3,:,:,:) = E(1:3,:,:,:,ElemID)
       HelperU(4:6,:,:,:) = B(1:3,:,:,:,ElemID)
-      CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),ElemID)
+      CALL eval_xyz_curved(Pos,6,PP_N,HelperU,field(1:6),ElemID,PartID)
 #endif
 #else
-      CALL eval_xyz_curved(Pos,3,PP_N,U(1:3,:,:,:,ElemID),field(1:3),ElemID)
+      CALL eval_xyz_curved(Pos,3,PP_N,U(1:3,:,:,:,ElemID),field(1:3),ElemID,PartID)
 #endif
 #endif
       FieldAtParticle(:) = FieldAtParticle(:) + field(1:6)
